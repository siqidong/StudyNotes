============================================================
TCP的三次握手：
在TCP/IP协议中，TCP提供可靠的连接服务，采用三次握手建立一个链接:
1. 第一次握手：建立连接时，client端发送SYN包(syn=j)到server端，
并进入SYN_SEND状态，等待server端确认;

2. 第二次握手：server端收到SYN包，必须确认client的SYN(ask=j+1)，
同时自己也要发送一个SYN包(syn=k)，即SYN+ACK包，此时server进入SYN_REVEIVED状态;

3. 第三次握手：client端收到server的SYN+ACK包，向server发送确认包
ACK (ask=k+1)，此包发送完成后，client和server端进入ESTABLISHED状态，
完成三次握手.

------------------------------------------------------------

Questions:
How to calculate seq/ack number?
* https://blog.csdn.net/HappyRocking/article/details/78198776

Why we need three handshakes to setup the connection?
* To initialize the Sequence Number.
* Client and server need to notify the other about their own 
sequence number, to guarantee the data being transferred get the 
correct order, and TCP need this sequence number to organize the data.

Danger zone about the first handshake - SYN timeout
Why?
* Server got client's SYN, after sending SYN+ACK, but didn't get ACK back.
* Server will keep resending the SYN+ACK, until get timeout.
In Linux, this timeout value is 5 times (= 1+2+4+8+16+32 = 63 seconds)

What?
* SYN flood: when hackers keep sending SYN without sending ACK.
* For each SYN, server needs 63 seconds to stop the connection.
* Hackers therefore can consume all SYN in server to prevent normal SYN request.

How to protect?
* After SYN queue is full, sever send SYN cookie thru tcp_syncookie sequence number.
* Hackers won't respond to this sequence number;
but normal clients will send back a SYN Cookie to set up the connection directly.

After setup the connection, client no response?
Keep alive mechanism.
* Keep sending packets to client, within each keep alive interval.
* Stop the connection after reaching the number of keep alive message 
without receiving a response from client.


============================================================
TCP的四次挥手:
采用四次挥手来释放链接
1. 第一次挥手：client发送一个FIN，用来关闭client到server的数据传送，client进入FIN_WAIT_1状态
2. 第二次挥手：server收到FIN后，发送一个ACK给client，seq为ack+1
client进入FIN_WAIT_2状态, server进入CLOSE_WAIT状态
3. 第三次挥手：server发送一个FIN，用来关闭server到client的数据传送，server进入LAST_ACK状态
4. 第四次挥手：client收到FIN后，client进入TIME_WAIT状态，接着发送一个ACK给server，seq为ack+1,
server进入CLOSED状态，完成四次挥手.

------------------------------------------------------------

Questions:
Why there is a time wait status?
* Guarantee there is enough time for the other to get ACK packet
* Avoid confusing old and new connections

Why we need four handshakes to close the connection?
* Because TCP is full-duplex, so both client and server need FIN and ACK packets.

Why there are many CLOSE_WAIT on server?
After client sending FIN packet, server is busing on reading/writing, 
forget to check FIN packet.
* Bugs in code, didn't release resources in time
* Bugs in configuration, wrong config for thread pool.
Linus: 
$ netstat -n | awk '/^tcp/{++S[$NF]}END{for(a in S) print a,S[a]}'

Learn $ netstat commands: (must!)
https://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316661.html

============================================================

UDP的特点：
* 面向非链接
* 不维护链接状态，支持向多个客户端传输相同消息
* 数据包overhead只有8个byte，额外开销少
* 吞吐量只受限于数据生成速率，传输速度，机器性能
* 尽最大努力交付，不保证可靠交付，不需要维持复杂的链接状态表
* 面向报文，不对应用程序提供的报文进行拆分或合并

Differences between TCP / UDP:

TCP: connection oriented, three handshakes;
     Reliable, will resend packets if not received;
     Guarantee the order of packets;
     Slow;
     Heavy weight, 20 bytes overhead;
UDP: connectionless;
     Not reliable, drop packet;
     Orderless;
     Fast, for online video etc.;
     Light weight, 8 bytes overhead;














